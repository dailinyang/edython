"""Parse the turtle documentation for function entries"""
import xml.etree.ElementTree as ET
import urllib.request
import pathlib
import re
import datetime

path_root = pathlib.Path(__file__).parent.parent.parent
path_in = path_root / 'build/helpers/turtle.html'
path_out = path_root / 'src/lib/eyo/core/turtle_model.js'

by_name = {}
items = []
categories = set()
types = set()

def export_model():

    depth = 0
    indent = '  '

    def do_head_print(*args):
        nonlocal depth, indent
        print(depth * indent, *args, sep='', end='', file=f)

    def do_print(*args):
        nonlocal depth, indent
        print("\n", depth * indent, *args, sep='', end='', file=f)

    def do_print_sep(*args, s7r=','):
        nonlocal depth, indent
        print(s7r, "\n", depth * indent, *args, sep='', end='', file=f)

    def do_print_item(separator, item):

        def do_print_item_attribute(key):
            do_print_sep("{}: '{}'".format(key, item[key]))

        def do_print_item_attribute_n(key):
            do_print_sep("{}: {}".format(key, item[key]))


        def do_print_argument_attribute(key, s7r=','):
            do_print_sep("{}: '{}'".format(key, argument[key]), s7r=s7r)

        do_print_sep("{", s7r=separator)
        nonlocal depth
        depth += 1
        do_print("names: ['{}']".format("', '".join(item['names'])))
        do_print_item_attribute('category')
        if 'description' in item:
            do_print_item_attribute('description')
        do_print_item_attribute('type')
        if 'arguments' in item:
            arguments = item['arguments']
            if len(arguments):
                do_print_item_attribute_n('ary')
                do_print_item_attribute_n('mandatory')
                do_print_sep("arguments: [")
                end = ''
                depth += 1
                for argument in arguments:
                    do_print_sep("{", s7r=end)
                    depth += 1
                    do_print_argument_attribute('name', s7r="")
                    if 'default' in argument:
                        do_print_argument_attribute('default')
                    if 'description' in argument:
                        do_print_argument_attribute('description')
                    depth -= 1
                    do_print("}")
                    end = ','
                depth -= 1
                do_print("]")
        else:
            do_print_sep("caller: true")
        depth -= 1
        do_print("}")

    with path_out.open('w') as f:

        do_head_print("""/**
 * edython
 *
 * Copyright 2018 Jérôme LAURENS.
 *
 * License EUPL-1.2
 */

/**
 * @fileoverview turtle model. Automatically generated by `bin/helpers/turtlebot.py`
 * @author jerome.laurens@u-bourgogne.fr (Jérôme LAURENS)
 */
'use strict'

goog.provide('eYo.Model.turtle__module')

goog.require('eYo.Model')
""")
        do_print('eYo.Model.turtle__module.data = {')
        depth += 1
        do_print('categories: [')
        depth += 1
        separator = ''
        for category in categories:
            do_print_sep("'{}'".format(category), s7r=separator)
            separator = ','
        del separator
        depth -= 1
        do_print(']')
        do_print_sep('items: [')
        depth += 1
        separator = ''
        for item in items:
            do_print_item(separator, item)
            separator = ','
        depth -= 1
        do_print(']')
        do_print_sep('by_name: {')
        depth += 1
        separator = ''
        for (name, index) in by_name.items():
            do_print_sep("'{}': {}".format(name, index), s7r = separator)
            separator = ','
        depth -= 1
        do_print('}')
        do_print_sep('by_category: {')
        depth += 1
        separator = ''
        for category in categories:
            ra = []
            for item in items:
                if item['category'] == category:
                    ra.append(str(item['index']))
            if len(ra) > 0:
                do_print_sep("'{}': [{}]".format(category, ", ".join(ra)), s7r=separator)
                separator = ","
        depth -= 1
        do_print('}')
        depth -= 1
        do_print('}')
        do_print("""
/**
 * Get the item with the given key
 * @param {!String|Number} key  The key or index of the item
 * @return {?Object} return the model object for that item, if any.
 */
eYo.Model.turtle__module.getItem = function (key) {
  if (!goog.isNumber(key)) {
    key = eYo.Model.turtle__module.data.by_name[key]
  }
  if (goog.isNumber(key)) {
    return eYo.Model.turtle__module.data.items[key]
  }
}

/**
 * Get the indices of the items for the given category
 * @param {!String} key  The name of the category
 * @return {!Array} the list of item indices with the given category (possibly void).
 */
eYo.Model.turtle__module.getItemsInCategory = function (category) {
  return eYo.Model.turtle__module.data.by_category[category] || []
}
""")
        do_print(
            '// This file was generated by `./bin/helpers/turtlebot.py` on {}\n\n'.format(datetime.datetime.utcnow()))

def import_model():
    if not path_in.exists():
        urllib.request.urlretrieve ("https://docs.python.org/3.6/library/turtle.html", path_in)
    with path_in.open('r') as f:
        content = f.read()
        content = content.replace('&copy;', '©')
        root = ET.fromstring(content)
        parent_map = {c: p for p in root.iter() for c in p}
        # start with all the functions
        for dl in root.iter("{http://www.w3.org/1999/xhtml}dl"):
            type = dl.get('class')
            if not type:
                continue
            descriptions_by_name = {}
            dd = dl.find("{http://www.w3.org/1999/xhtml}dd")
            if dd:
                descriptions = []
                td = dd.find(".//{http://www.w3.org/1999/xhtml}td")
                if td:
                    ul = td.find(".//{http://www.w3.org/1999/xhtml}ul")
                    if ul:
                        for li in ul.findall(".//{http://www.w3.org/1999/xhtml}li"):
                            descriptions.append("".join(li.itertext()))
                    else:
                        descriptions.append("".join(td.itertext()))
                for description in descriptions:
                    m = re.match(r'^(.*?)\s*[-–]\s*(.*?)$', description, re.DOTALL)
                    if m:
                        descriptions_by_name[m.group(1)] = m.group(2)
                    else:
                        print('NO MATCH IN', description)
            ancestor = parent_map[dl]
            category = ancestor.get('id')
            names = []
            arguments = None
            ary = 0
            mandatory = 0
            for dt in dl.findall("{http://www.w3.org/1999/xhtml}dt"):
                codes = list(dt.findall("{http://www.w3.org/1999/xhtml}code"))
                if len(codes) > 1 :
                    code = codes[1]
                    name = code.text
                    if name:
                        names.append(name)
                        if not arguments:
                            arguments = []
                            for ems in dt.findall("{http://www.w3.org/1999/xhtml}em"):
                                for em in re.split(r'\s*,\s*', ems.text):
                                    ary += 1
                                    m = re.match('([^=\s]+)\s*=\s*([^=\s]+)', em)
                                    argument = {}
                                    if m:
                                        argument['name'] = m.group(1).strip()
                                        argument['default'] = m.group(2).strip()
                                    else:
                                        mandatory += 1
                                        argument['name'] = em.strip()
                                    key = argument['name']
                                    if key in descriptions_by_name:
                                        argument['description'] = descriptions_by_name[key].\
                                            replace('\n', ' ').replace("'", "\\'").strip()
                                    arguments.append(argument)

            if len(names):
                categories.add(category)
                types.add(type)
                names = sorted(names, key=lambda x: (x.find('_') < 0, -len(x)))
                item = {
                    'names': names,
                    'arguments': arguments,
                    'category': category,
                    'type': type,
                    'ary': ary,
                    'mandatory': mandatory
                }
                item['index'] = len(items)
                for name in names:
                    by_name[name] = item['index']
                items.append(item)

import_model()
export_model()
