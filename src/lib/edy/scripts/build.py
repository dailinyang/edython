#!/usr/bin/python3
# Compresses the necesary closure-library files.
#
# Copyright 2018 jerome dot laurens at u-bourgogne dot fr.
#
# Licensed under CeCILL-B.

# Usage: build.py.

# This script generates edy-closure-library_compressed.js.

import sys
if sys.version_info[0] < 3:
  raise Exception("build only compatible with Python 3.5+.\n"
                  "You are using: " + sys.version)

if len(sys.argv)>1:
    raise Exception("No arguments supported")

import errno, glob, http.client, json, os, re, subprocess, threading, urllib
import importlib.util

def import_module_at(name, fullpath):
  """Import a module givn its full path, returns the module"""
  spec = importlib.util.spec_from_file_location(name, fullpath)
  module = importlib.util.module_from_spec(spec)
  spec.loader.exec_module(module)
  return module

libpath = os.path.pardir

try:
  calcdeps = import_module_at('calcdeps', os.path.join(libpath, "closure-library", "closure", "bin", "calcdeps.py"))
except ImportError:
  print("""Error: Closure not found.""")
  sys.exit(1)

HEADER = ("// Do not edit this file; automatically generated by build.py.\n"
          "'use strict';\n")

class Gen_compressed(threading.Thread):
  """Generate a JavaScript file that contains all of Blockly's core and all
  required parts of Closure, compiled together.
  Uses the Closure Compiler's online API.
  Runs in a separate thread.
  """
  def __init__(self):
    threading.Thread.__init__(self)

  def get_search_path(self):
    return sorted([x for x in calcdeps.ExpandDirectories(
      ["core", "blockly", "closure-library", os.path.join(libpath, "closure-library")])])

  def get_dependencies(self, dirs):
    filenames = []
    for dir in ["core", "blockly", "closure-library"]:
      for root, _, files in os.walk(dir):
        for filename in files:
          if len(root) > 1 and re.match(r'.*\.js', filename) and not re.match(r'.*_test.*', filename):
            path = os.path.join(root, filename)
            filenames.append(path)
    filenames = [f for f in set(calcdeps.CalculateDependencies(self.get_search_path(),filenames))]
    filenames.sort()
    return filenames

  def run(self):
    target_filename = "ezp_compressed.js"
    # Define the parameters for the POST request.
    params = [
        ("compilation_level", "SIMPLE_OPTIMIZATIONS"),
        ("use_closure_library", "true"),
        ("output_format", "json"),
        ("output_info", "compiled_code"),
        ("output_info", "warnings"),
        ("output_info", "errors"),
        ("output_info", "statistics"),
      ]

    filenames = self.get_dependencies(["core", "blockly", "closure-library"])

    for filename in filenames:
      # Filter out the Closure files (the compiler will add them).
      if filename.startswith(os.pardir + os.sep):  # '../'
        continue
      print(filename)
      with open(filename, 'r', encoding='utf8') as f:
        params.append(("js_code", "".join(f.readlines())))
    print('self.do_compile', params)
    self.do_compile(params, target_filename, filenames, "")

  def do_compile(self, params, target_filename, filenames, remove):
    # Send the request to Google.
    headers = {"Content-type": "application/x-www-form-urlencoded"}
    conn = http.client.HTTPSConnection("closure-compiler.appspot.com")
    conn.request("POST", "/compile", urllib.parse.urlencode(params), headers)
    response = conn.getresponse()
    json_bytes = response.read()
    conn.close()
    json_str = json_bytes.decode("utf-8")
    print('Response received '+json_str)
    # Parse the JSON response.
    json_data = json.loads(json_str)

    def file_lookup(name):
      if not name.startswith("Input_"):
        return "???"
      n = int(name[6:]) - 1
      return filenames[n]

    if "serverErrors" in json_data:
      errors = json_data["serverErrors"]
      for error in errors:
        print("SERVER ERROR: %s" % target_filename)
        print(error["error"])
    elif "errors" in json_data:
      errors = json_data["errors"]
      for error in errors:
        print("FATAL ERROR")
        print(error["error"])
        if error["file"]:
          print("%s at line %d:" % (
              file_lookup(error["file"]), error["lineno"]))
          print(error["line"])
          print((" " * error["charno"]) + "^")
        sys.exit(1)
    else:
      if "warnings" in json_data:
        warnings = json_data["warnings"]
        for warning in warnings:
          print("WARNING")
          print(warning["warning"])
          if warning["file"]:
            print("%s at line %d:" % (
                file_lookup(warning["file"]), warning["lineno"]))
            print(warning["line"])
            print((" " * warning["charno"]) + "^")
        print()

      if not "compiledCode" in json_data:
        print("FATAL ERROR: Compiler did not return compiledCode.")
        sys.exit(1)

      code = HEADER + "\n" + json_data["compiledCode"]
      code = code.replace(remove, "")

      code = code.replace("Blockly=", "BlocklyHolder=")

      # Trim down Google's (and only Google's) Apache licences.
      # The Closure Compiler preserves these.

      stats = json_data["statistics"]
      original_b = stats["originalSize"]
      compressed_b = stats["compressedSize"]
      if original_b > 0 and compressed_b > 0:
        with open(target_filename, "w") as f:
          f.write(code)

        original_kb = int(original_b / 1024 + 0.5)
        compressed_kb = int(compressed_b / 1024 + 0.5)
        ratio = int(float(compressed_b) / float(original_b) * 100 + 0.5)
        print("SUCCESS: " + target_filename)
        print("Size changed from %d KB to %d KB (%d%%)." % (
            original_kb, compressed_kb, ratio))
      else:
        print("UNKNOWN ERROR")

if __name__ == "__main__":

  # Compressed is limited by network and server speed.
  Gen_compressed().start()
