/**
 * edython
 *
 * Copyright 2019 Jérôme LAURENS.
 *
 * @license EUPL-1.2
 */
/**
 * @fileoverview Flyout overriden.
 * @author jerome.laurens@u-bourgogne.fr (Jérôme LAURENS)
 */
'use strict'

goog.provide('eYo.Flyout')

goog.require('eYo.Unit')

goog.forwardDeclare('eYo.FlyoutCategory');
goog.forwardDeclare('eYo.Style');
goog.forwardDeclare('eYo.Brick');
goog.forwardDeclare('eYo.FlyoutToolbar');
goog.forwardDeclare('eYo.Tooltip');
goog.forwardDeclare('eYo.MenuRenderer');
goog.forwardDeclare('eYo.MenuButtonRenderer');

/**
 * Class for a flyout.
 * @param {!eYo.Board} owner  The owning board, which must be a main board.
 * @param {!Object} flyoutOptions Dictionary of options for the board.
 * @constructor
 */
eYo.Flyout = function(owner, flyoutOptions) {
  goog.asserts.assert(owner.isMain, 'Only main boards may have a flyout')
  goog.asserts.assert(!owner.hasUI, 'TOO LATE')
  // First
  this.owner_ = owner
  var board = /*this.board_ = */new eYo.Board(this, {})

  if (!this.autoClose) {
    this.filterWrapper_ = this.filterForCapacity_.bind(this)
    owner.addChangeListener(this.filterWrapper_)
  }
  board.options = owner.options
  /**
   * Position of the flyout relative to the board.
   * @type {number}
   * @private
   */
  this.anchor_ = flyoutOptions.anchor || eYo.Flyout.AT_RIGHT
  
  /**
   * Position and dimensions of the flyout in the desk.
   * @type {number}
   * @private
   */
  this.viewRect_ = new eYo.Rect().tie(board.metrics_.view, {
    l: (newValue) => newValue + eYo.Flyout.TOOLBAR_HEIGHT,
    h: (newValue) => newValue - eYo.Flyout.TOOLBAR_HEIGHT,
  }, {
    l: (newValue) => newValue - eYo.Flyout.TOOLBAR_HEIGHT,
    h: (newValue) => newValue + eYo.Flyout.TOOLBAR_HEIGHT,
  })
  /**
   * Opaque data that can be passed to unbindEvent.
   * @type {!Array.<!Array>}
   * @private
   */
  this.eventWrappers_ = []
  /**
   * List of event listeners.
   * Array of opaque data that can be passed to unbindEvent.
   * @type {!Array.<!Array>}
   * @private
   */
  this.listeners_ = []
  /**
   * List of bricks that should always be disabled.
   * @type {!Array.<!eYo.Brick>}
   * @private
   */
  this.permanentlyDisabled_ = []

  if (flyoutOptions.autoClose) {
    this.autoClose = true
  }
  this.disposeUI = eYo.Do.nothing
}

Object.defineProperties(eYo.Flyout.prototype, {
  /**
   * The desk
   * @type {eYo.Desk}
   * @readonly
   */
  desk: { 
    get () {
      return this.owner_.desk
    }
  },
  /**
   * @type {eYo.Board} The board inside the flyout.
   */
  board: {
    get () {
      return this.board_
    }
  },
  /**
   * Whether the flyout is closed.
   * @type {boolean}
   * @readonly
   */
  closed: {
    get () {
      return this.closed_
    }
  },
  /**
   * Does the flyout automatically close when a brick is created?
   * @type {boolean}
   */
  autoClose: { value: true, writable: true},
  /**
   * Whether the flyout is visible.
   * @type {boolean}
   * @private
   */
  visible_: { value: false, writable: true},
  /**
   * Whether the flyout is closed.
   * @type {boolean}
   * @private
   */
  closed_: { value: false, writable: true},
  /**
   * Whether the board containing this flyout is visible.
   * @type {boolean}
   * @private
   */
  containerVisible_: { value: true, writable: true},
  /**
   * Width of flyout.
   * @type {number}
   * @private
   */
  width_: {
    get () {
      return this.viewRect_.size_.width
    },
    set (newValue) {
      if (this.viewRect_.size_.width !== newValue) {
        this.viewRect_.size_.width = newValue
        this.desk.board.layout()
      }
    }
  },
  /**
   * Height of flyout.
   * @type {number}
   * @private
   */
  height_: {
    get () {
      return this.viewRect_.size_.height
    },
    set (newValue) {
      if (this.viewRect_.size_.height !== newValue) {
        this.viewRect_.size_.height = newValue
        this.desk.board.layout()
      }
    }
  },
  /**
   * This size and anchor of the receiver and wrapped
   * in an object with eponym keys.
   */
  size: {
    get () {
      var ans = new eYo.Size(this.viewRect_.size_)
      ans.anchor = this.anchor_
      return ans
    },
    set (newValue) {
      if ((newValue.equals(this.viewRect_.size))) {
        this.viewRect_.size = newValue
        this.sizeChanged()
      }
    }
  },
  /**
   * Range of a drag angle from a flyout considered "dragging toward board".
   * Drags that are within the bounds of this many degrees from the orthogonal
   * line to the flyout edge are considered to be "drags toward the board".
   * Example:
   * Flyout                                                  Edge   Board
   * [brick] /  <-within this angle, drags "toward board" |
   * [brick] ---- orthogonal to flyout boundary ----          |
   * [brick] \                                                |
   * The angle is given in degrees from the orthogonal.
   *
   * This is used to know when to create a new brick and when to scroll the
   * flyout. Setting it to 360 means that all drags create a new brick.
   * @type {number}
   * @private
  */
  dragAngleLimit_: { value: 70, writable: true},
  /**
   * Return the deletion rectangle for this flyout in viewport coordinates.
   * Edython : add management of the 0 width rectange
   * @return {eYo.Rect} Rectangle in which to delete.
   */
  deleteRect: {
    get () {
      var rect = this.viewRect
      var width = rect.width
      if (!width) {
        return null
      }
      // BIG_NUM is offscreen padding so that bricks dragged beyond the shown flyout
      // area are still deleted.  Must be larger than the largest screen size,
      // but be smaller than half Number.MAX_SAFE_INTEGER (not available on IE).
      var BIG_NUM = 1000000000
      if (this.atRight) {
        rect.right += BIG_NUM
      } else {
        rect.left -= BIG_NUM
      }
      rect.top = BIG_NUM
      rect.bottom = BIG_NUM
      return rect
    }
  },
  toolbar: {
    get () {
      return this.toolbar_
    }
  }
})

/**
 * Make the UI
 */
eYo.Flyout.prototype.makeUI = function () {
  delete this.disposeUI
  this.makeUI = eYo.Do.nothing
  this.board_.makeUI()
  this.hide()
  var d = this.ui_driver
  d.flyoutInit(this)
  if (flyoutOptions.switcher) {
    var tb = this.toolbar_ = new eYo.FlyoutToolbar(this, flyoutOptions.switcher)
    d.flyoutToolbarInit(tb)
    tb.doSelectGeneral(null) // is it necessary ?
  }
}

/**
 * Dispose of this flyout UI resources.
 * Unlink from all DOM elements to prevent memory leaks.
 */
eYo.Flyout.prototype.disposeUI = function() {
  delete this.makeUI
  this.disposeUI = eYo.Do.nothing
  this.hide()
  this.board_.disposeUI()
  var d = this.ui_driver
  this.toolbar_ && d.flyoutToolbarDispose(this.toolbar_)
  d.flyoutDispose(this)
  eYo.Do.disposeProperty(this, "scrollbar_")
}

/**
 * Dispose of this flyout.
 * Sever all links.
 */
eYo.Flyout.prototype.dispose = function() {
  this.disposeUI()
  eYo.Do.disposeProperties(this, ["viewRect_"])
  if (!this.filterWrapper_) {
    this.owner_.removeChangeListener(this.filterWrapper_)
  }
  this.board_.dispose()
  this.owner_ = this.board_ = null
  this.dispose = eYo.Do.nothing
}

/**
 * When the size of the receiver did change.
 */
eYo.Flyout.prototype.sizeChanged = function() {
  this.desk.board.layout()
  this.board_.layout()
}

Object.defineProperties(eYo.Flyout, {
  AT_RIGHT: { value: 1 },
  AT_LEFT: { value: 2 },
  /**
   * Top/bottom padding between scrollbar and edge of flyout background.
   * @type {number}
   * @const
   */
  SCROLLBAR_PADDING: { value: 2 },
  TOP_MARGIN: { value: 0 }, // 4 * eYo.Unit.rem
  BOTTOM_MARGIN: { value: 16 }, // scroll bar width
  TOOLBAR_HEIGHT : { value: Math.round(2 * eYo.Unit.y) },
  /**
   * Margin around the edges of the bricks.
   * @type {number}
   * @const
   */
  MARGIN : { value: eYo.Unit.rem / 4 },
  /**
   * This size and anchor of the receiver and wrapped
   * in an object with eponym keys.
   */
})

Object.defineProperties(eYo.Flyout.prototype, {
  hasUI: {
    get () {
      return this.makeUI === eYo.Do.nothing
    }
  },
  /**
   * The rect of the receiver in the desk
   * @type {eYo.Rect}
   * @readonly
   */
  viewRect: {
    get () {
      return this.viewRect_.clone
    }
  },
  position: {
    get () {
      return this.viewRect_.origin
    },
    set (newValue) {
      this.viewRect_.origin = newValue
    }
  },
  /**
   * @readonly
   * @type {number} The width of the flyout.
   */
  width: {
    get () {
      return this.viewRect_.size_.width
    }
  },
  /**
   * @readonly
   * @type {number} The height of the flyout.
   */
  height: {
    get () {
      return this.viewRect_.size_.height
    }
  },
  /**
   * Is the flyout visible?
   * @type {boolean} True if visible.
   */
  visible: {
    get () {
      return this.visible_
    },
    set (visible) {
      if(visible != this.visible_) {
        this.visible_ = visible
        this.updateDisplay_()
      }
    }
  },
  /**
   * Whether this flyout's container is visible.
   * @type {boolean}
   */
  containerVisible: {
    get () {
      return this.containerVisible_
    },
    set (visible) {
      if(visible != this.containerVisible_) {
        this.containerVisible_ = visible
        this.updateDisplay_()
      }
    }
  },
  /**
   * @type {eYo.Scrollbar}.
   */
  scrollbar: {
    get () {
      return this.board.scrollbar
    }
  },
  /**
   * @type {boolean} True if this flyout may be scrolled with a scrollbar or by
   *     dragging.
   */
  scrollable: {
    get () {
      return this.board.scrollable
    }
  },
  /**
   * @type {Number} where the flyout is anchored.
   */
  anchor: {
    get () {
      return this.anchor_
    }
  },
  /**
   * @type {Boolean} Is it anchored at right ?
   * @readonly
   */
  atRight: {
    get () {
      return this.anchor_ === eYo.Flyout.AT_RIGHT
    }
  },
})

/**
 * Update the display property of the flyout based whether it thinks it should
 * be visible and whether its containing board is visible.
 * @private
 */
eYo.Flyout.prototype.updateDisplay_ = function() {
  var show = this.containerVisible_ && this.visible_
  this.ui_driver.flyoutDisplaySet(show)
  // Update the scrollbar's visiblity too since it should mimic the
  // flyout's visibility.
  this.scrollbar.containerVisible = show
}

/**
 * Hide and empty the flyout.
 */
eYo.Flyout.prototype.hide = function() {
  if (!this.visible) {
    return
  }
  this.visible = false
  this.ui_driver.flyoutRemoveListeners(this)
  if (this.reflowWrapper_) {
    this.board_.removeChangeListener(this.reflowWrapper_)
    this.reflowWrapper_ = null
  }
  // Do NOT delete the bricks here.  Wait until Flyout.show.
  // https://neil.fraser.name/news/2014/08/09/
}

/**
 * Show and populate the flyout.
 * More tagnames accepted.
 * @param {!Array|string} model List of bricks to show.
 */
eYo.Flyout.prototype.show = function(model) {
  this.board_.setResizesEnabled(false)
  this.hide()
  eYo.Events.disableWrap(() => {
    // Delete any bricks from a previous showing.
    this.board_.topBricks.forEach(brick => brick.dispose())
    // Create the bricks to be shown in this flyout.
    var contents = []
    this.permanentlyDisabled_.length = 0
    model.forEach(xml => {
      if (xml.tagName) {
        var tagName = xml.tagName.toUpperCase()
        if (tagName.startsWith('EYO:')) {
          var curBrick = eYo.Xml.domToBrick(xml, this.board_)
          if (curBrick.disabled) {
            // Record bricks that were initially disabled.
            // Do not enable these bricks as a result of capacity filtering.
            this.permanentlyDisabled_.push(curBrick)
          }
          contents.push(curBrick)
        }
      } else {
        var createOneBrick = xml => {
          try {
            var brick = this.board_.newBrick(xml)
            contents.push(brick)
            brick.ui.addTooltip(xml.title || (xml.data && xml.data.main) || xml.data)
          } catch (err) {
            console.error(xml, err)
            // throw err: catch the error here definitely
          }
        }
        // this is the part specific to edython
        if (goog.isFunction(xml)) {
          // xml is either a function that returns an array of objects
          // or a function that creates brick.
          var ra = xml(createOneBrick)
          if (ra && ra.forEach) {
            ra.forEach(createOneBrick)
          }
        } else {
          createOneBrick(xml)
        }
      }
    })

    this.visible = true
    this.layout_(contents)

    // IE 11 is an incompetent browser that fails to fire mouseout events.
    // When the mouse is over the background, deselect all bricks.
    this.ui_driver.flyoutListen_mouseover(this)

    this.board_.setResizesEnabled(true)
    this.reflow()

    this.filterForCapacity_()

    // Correctly position the flyout's scrollbar when it opens.
    this.place()

    this.reflowWrapper_ = this.reflow.bind(this)
    this.board_.addChangeListener(this.reflowWrapper_)
  })
}

/**
 * Scroll the flyout.
 * @param {!Event} e Mouse wheel scroll event.
 * @private
 */
eYo.Flyout.prototype.on_wheel = function(e) {
  var delta = e.deltaY
  if (delta) {
    if (goog.userAgent.GECKO) {
      // Firefox's deltas are a tenth that of Chrome/Safari.
      delta *= 10
    }
    var metrics = this.board.metrics
    metrics.drag = metrics.drag.forward({x: 0, y: delta})
  }
  eYo.Dom.gobbleEvent(e)
}

/**
 * Create a copy of this brick on the board.
 * @param {!eYo.Brick} originalBrick The brick to copy from the flyout.
 * @return {eYo.Brick} The newly created brick, or null if something
 *     went wrong with deserialization.
 */
eYo.Flyout.prototype.createBrick = function(originalBrick) {
  this.desk.board.setResizesEnabled(false)
  var newBrick
  eYo.Events.disableWrap(() => {
    newBrick = this.placeNewBrick_(originalBrick)
    // Close the flyout.
    eYo.App.hideChaff()
  })
  eYo.Events.fireBrickCreate(newBrick, true)
  if (this.autoClose) {
    this.hide()
  } else {
    this.filterForCapacity_()
  }
  return newBrick
}

/**
 * Does the job of sliding the flyout in or out.
 * @param {?Boolean} close  close corresponds to the final state.
 * When not given, toggle the closed state.
 */
eYo.Flyout.prototype.doSlide = function(close) {
  // nothing to do if in the process of reaching the expected state
  if (this.slide_locked) {
    return
  }
  if (!goog.isDef(close)) {
    close = !this.closed
  }
  // nothing to do either if already in the expected state
  if (!close === !this.closed) {
    return
  }
  this.slide_locked = true
  this.visible = true
  eYo.Tooltip.hideAll(this.dom.svg.group_)
  var rect = this.viewRect_
  var x_min = rect.x_min
  var x_max = rect.x_max
  var n_steps = 50
  var n = 0
  var steps = []
  var positions = []
  if (this.atRight) {
    var x_start = close ? x_min : x_max
    var x_end = close ? x_max : x_min
  } else {
    x_start = close ? x_min : x_min - rect.width
    x_end = close ? x_min - rect.width : x_min
  }
  steps[0] = close ? 0: 1
  positions[0] = x_start
  for (n = 1; n < n_steps; n++) {
    var step = Math.sin(n*Math.PI/n_steps/2)**2
    steps[n] = close ? step : 1 - step
    positions[n] = x_start + step * (x_end - x_start)
  }
  steps[n] = close ? 1 : 0
  positions[n] = x_end

  n = 0
  var f = () => {
    if (n >= n_steps) {
      rect.x = x_end
      clearInterval(id)
      if ((this.closed_ = close)) {
        this.visible = false
      }
      this.ui_driver.flyoutUpdate(this)
      delete this.slide_locked
      this.desk_.recordDeleteAreas()
      this.slideOneStep(steps[n_steps])
      this.didSlide(close)
      this.abortSlide = eYo.Do.nothing
    } else {
      rect.x = positions[n]
      this.ui_driver.flyoutPlace(this)
      // the scrollbar won't layout because the metrics of the board did not change
      this.slideOneStep(steps[n])
      ++n
    }
  }
  var id = setInterval(f, 20)
  this.abortSlide = function () {
    n = n_steps
    f()
  }
}

/**
 * Slide the flyout in or out.
 * This 2 levels design allows overwriting.
 * Actually, the ui button calls the slide method.
 * @param {?Boolean} close  close corresponds to the final state.
 * When not given, toggle the closed state.
 */
eYo.Flyout.prototype.slide = function(close) {
  this.doSlide(close)
}

/**
 * Subclassers will add there stuff here.
 * @param {number} step betwwen 0 and 1.
 */
eYo.Flyout.prototype.slideOneStep = function(step) {
}

/**
 * Subclassers will add there stuff here.
 * @param {Boolean} closed
 */
eYo.Flyout.prototype.didSlide = function(closed) {
}

/**
 * List of node models by category.
 * Used by the front end.
 * @param {!String} category The name of the category to retrieve.
 */
eYo.Flyout.prototype.getList = function (category) {
  return eYo.FlyoutCategory[category] || []
}

/**
 * Update metrics, nothing more nothing less.
 * The size and location of the view may change due to user interaction,
 * for example a window resize, a pane resize.
 * The driver updates the internal state accordingly.
 * This must be called at initialization time, when building the UI,
 * and each time some change occurs that modifies the geometry.
 */
eYo.Flyout.prototype.updateMetrics = function() {
  // if the flyout is moving, either opening or closing,
  // stop moving
  this.abortSlide() // ideally, sliding would follow the new metrics
  var view = this.desk.board.metrics.view
  var r = this.viewRect_
  r.size_.height = view.height
  r.size_.width = Math.min(view.width / 3, Math.max(this.board.metrics.port.width, eYo.Unit.x * 10))
  var where = this.atRight ? view.right : view.left
  if (!this.closed === !this.atRight) {
    r.origin_.x_min = where
  } else {
    r.origin_.x_max = view.right
  }
  this.ui_driver.flyoutUpdateMetrics(this)
  this.toolbar.updateMetrics()
  this.board.updateMetrics()
}

