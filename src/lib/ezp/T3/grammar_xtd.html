
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<body>
<pre>
    sdf
</pre>
#single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
#file_input: (NEWLINE | stmt)* ENDMARKER
#eval_input: testlist NEWLINE* ENDMARKER
decorator_stmt: '@' dotted_name [ arglist_void ]
arglist_void: '(' (argument ',')* [ argument ] ')'
#decorators: decorator+
#decorated: decorators (classdef | funcdef | async_funcdef)
#async_funcdef: ASYNC funcdef
#funcdef: 'def' NAME parameters [ '->' test] ':' suite
funcdef_part: 'def' NAME parameters [ '->' test] ':'
parameters: '(' [typedargslist] ')'
typedargslist: (tfpdef_def ( ',' tfpdef_def)* [ ',' [ '*' [tfpdef] ( ',' tfpdef_def)* [ ',' [ tfpdef_star_star [ ',' ]]] | tfpdef_star_star [ ',' ]]] | '*' [tfpdef] ( ',' tfpdef_def)* [ ',' [ tfpdef_star_star [ ',' ]]] | tfpdef_star_star [ ',' ])
tfpdef_star_star: '**' tfpdef
tfpdef_def: tfpdef [ '=' test]
#tfpdef: NAME [ ':' test]
varargslist: (vfpdef_def ( ',' vfpdef_def)* [ ',' [ '*' [vfpdef] ( ',' vfpdef_def)* [ ',' [ vfpdef_star_star [ ',' ]]] | vfpdef_star_star [ ',' ]]] | '*' [vfpdef] ( ',' vfpdef_def)* [ ',' [ vfpdef_star_star [ ',' ]]] | vfpdef_star_star [ ',' ]
)
vfpdef_star_star: '**' vfpdef
vfpdef_def: vfpdef [ '=' test]
#vfpdef: NAME
#stmt: simple_stmt | compound_stmt
#simple_stmt: small_stmt ( ';' small_stmt)* [ ';' ] NEWLINE
#small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
#expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) | ( '=' (yield_expr|testlist_star_expr))*)
#annassign: ':' test [ '=' test]
testlist_star_expr: test_star_expr ( ',' test_star_expr)* [ ',' ]
test_star_expr: test|star_expr
#augassign: ( '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//=' )
#del_stmt: 'del' exprlist
#pass_stmt: 'pass'
#flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
#break_stmt: 'break'
#continue_stmt: 'continue'
return_stmt: 'return' testlist_void
testlist_void: [testlist]
yield_stmt: yield_expr
raise_stmt: 'raise' [raise_what]
raise_what: test [raise_from]
raise_from: 'from' test
import_stmt: import_name | import_from
import_name: 'import' dotted_as_names
import_from: 'from' import_from_what 'import' import_what
import_from_what: ( '.' | '...' )* dotted_name | ( '.' | '...' )+
import_what: '*' | '(' import_as_names ')' | import_as_names
#import_as_name: NAME [ 'as' NAME]
#dotted_as_name: dotted_name [ 'as' NAME]
#import_as_names: import_as_name ( ',' import_as_name)* [ ',' ]
#dotted_as_names: dotted_as_name ( ',' dotted_as_name)*
#dotted_name: NAME ( '.' NAME)*
global_stmt: 'global' NAME_list
NAME_list: NAME ( ',' NAME)*
nonlocal_stmt: 'nonlocal' NAME_list
assert_stmt: 'assert' test [assert_args]
assert_args: ',' test
#compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
#async_stmt: ASYNC (funcdef | with_stmt | for_stmt)
#if_stmt: 'if' test ':' suite ( 'elif' test ':' suite)* [ 'else' ':' suite]
if_part: 'if' test ':'
elif_part: 'elif' test ':'
else_part: 'else' ':'
else_part > if_part | elif_part
elif_part > if_part
#while_stmt: 'while' test ':' suite [ 'else' ':' suite]
while_part:  'while' test ':'
else_part > while_part
#for_stmt: 'for' exprlist 'in' testlist ':' suite [ 'else' ':' suite]
for_part ::=  'for' exprlist 'in' testlist ':'
else_part > for_part

test -> expression
exprlist -> target_list
testlist -> expression_list

try_part: 'try:'
except_part: except_clause ':'
void_except_part: void_except_clause ':'
except_clause: 'except' test [ 'as' NAME]
void_except_clause: 'except'
finally_part: 'finally:'

try_part < except_part | void_except_part | finally_part
except_part < except_part | void_except_part | else_part | finally_part
void_except_part < finally_part
except_part > try_part | except_part
void_except_part > try_part | except_part
else_part > except_part | void_except_part
finally_part > try_part | except_part | void_except_part | else_part

#try_stmt: ( 'try' ':' suite ((except_clause ':' suite)+ [ 'else' ':' suite] [ 'finally' ':' suite] | 'finally' ':' suite))
#with_stmt: 'with' with_item ( ',' with_item)* ':' suite
with_part: 'with' with_item_list ':'
with_item_list: with_item ( ',' with_item)*
#with_item: test [ 'as' expr]
#except_clause: 'except' [test [ 'as' NAME]]
#suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
#test: or_test [ 'if' or_test 'else' test] | lambdef
test: conditional_expression | lambdef
conditional_expression: or_test [if_optional]
lambdef -> lambda_expr
if_optional: 'if' or_test 'else' test
#test_nocond: or_test | lambdef_nocond
lambdef_nocond -> lambda_expr_nocond
expression_nocond:  or_test | lambda_expr_nocond
test_nocond -> expression_nocond
# test: test_nocond [if_optional]
lambdef: 'lambda' [varargslist] ':' test
lambdef_nocond: 'lambda' [varargslist] ':' test_nocond
#or_test: and_test ( 'or' and_test)*
or_test: and_test | or_test_solid
or_test_solid: and_test 'or' or_test
#and_test: not_test ( 'and' not_test)*
and_test: not_test | and_test_solid
and_test_solid: not_test 'and' and_test
#not_test: 'not' not_test | comparison
not_test: not_test_solid | comparison
not_test_solid: 'not' not_test
#comparison: expr (comp_op expr)*
comparison: expr | comparison_solid
comparison_solid: expr comp_op comparison
#comp_op: '<' | '>' | '==' | '>=' | '<=' | '<>' | '!=' | 'in' | 'not' 'in' | 'is' | 'is' 'not'
#star_expr: '*' expr
expr -> or_expr
#expr: xor_expr ( '|' xor_expr)*
expr: xor_expr | or_expr_solid
or_expr_solid: xor_expr '|' expr
#xor_expr: and_expr ( '^' and_expr)*
xor_expr: and_expr | xor_expr_solid
xor_expr_solid: and_expr '^' xor_expr
#and_expr: shift_expr ( '&' shift_expr)*
and_expr: shift_expr | and_expr_solid
and_expr_solid: shift_expr '&' and_expr
#shift_expr: arith_expr (( '<<' | '>>' ) arith_expr)*
shift_expr: arith_expr | shift_expr_solid
shift_expr_solid: arith_expr ( '<<' | '>>' ) shift_expr
#arith_expr: term (( '+' | '-' ) term)*
arith_expr: term | arith_expr_solid
arith_expr_solid: term ( '+' | '-' ) arith_expr
arith_expr -> a_expr
arith_expr_solid -> a_expr_solid
#term: factor (( '*' | '@' | '/' | '%' | '//' ) factor)*
term: factor | term_solid
term_solid: factor ( '*' | '@' | '/' | '%' | '//' ) term
term -> m_expr
term_solid -> m_expr_solid
#factor: ( '+' | '-' | '~' ) factor | power
factor: factor_solid | power
factor_solid: ( '+' | '-' | '~' ) factor
factor -> u_expr
factor_solid -> u_expr_solid
#power: atom_expr [ '**' factor]
power: atom_expr | power_solid
power_solid: atom_expr '**' factor

NAME -> identifier

#atom_expr: [AWAIT] atom trailer*
atom_expr -> await_or_primary
await_or_primary: await_expr | primary
await_expr: "await" primary
primary::= atom trailer*
#atom: ( '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False' )
atom: identifier | literal | enclosure | NTFDots
literal: stringliteral | bytesliteral | integer | floatnumber | imagnumber
NTFDots: '...' | 'None' | 'True' | 'False'
#enclosure: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}'

enclosure: parenth_form | yield_atom | list_display | dict_display | set_display | generator_expression

parenth_form: "(" [starred_expression] ")"
list_display: "[" [starred_list | comprehension] "]"

yield_atom: "(" yield_expression ")"
yield_expression: yield_expression_list | yield_from_expression
yield_expression_list: "yield" expression_list
?yield_from_expression: "yield from" expression

dict_display: "{" [key_datum_list | dict_comprehension] "}"
key_datum_list: key_datum ("," key_datum)* [","]
key_datum: key_datum_solid | or_expr_star_star
key_datum_solid: expression ":" expression
or_expr_star_star: "**" or_expr

dict_comprehension: expression ":" expression comp_for

set_display: "{" (starred_list | comprehension) "}"

generator_expression: "(" expression comp_for ")"

? testlist_comp -> starred_list | comprehension
? testlist_comp -> starred_expression

star_expr
testlist_comp: (test|star_expr) ( comp_for | ( ',' (test|star_expr))* [ ',' ] )

trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
subscriptlist: subscript ( ',' subscript)* [ ',' ]
subscript: test | [test] ':' [test] [sliceop]
sliceop: ':' [test]
exprlist: (expr|star_expr) ( ',' (expr|star_expr))* [ ',' ]
testlist: test ( ',' test)* [ ',' ]
dictorsetmaker: ( ((test ':' test | '**' expr) (comp_for | ( ',' (test ':' test | '**' expr))* [ ',' ])) | ((test | star_expr) (comp_for | ( ',' (test | star_expr))* [ ',' ])) )
classdef: 'class' NAME [ '(' [arglist] ')' ] ':' suite
arglist: argument ( ',' argument)* [ ',' ]
argument: ( test [comp_for] | test '=' test | '**' test | '*' test )
comp_iter: comp_for | comp_if
comp_for: [ASYNC] 'for' exprlist 'in' or_test [comp_iter]
comp_if: 'if' test_nocond [comp_iter]
encoding_decl: NAME
yield_expr: 'yield' [yield_arg]
yield_arg: 'from' test | testlist

</body>
</html>