
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<body>
This HTML file is not expected to be rendered.
The purpose is just to give something similar to the official python documentation at
https://docs.python.org/3.6/reference/expressions.html
end next, in order to use the same parser.

What is important is enclosed between pre tags
Definitions follow the pseudo grammar use in the documentation mentioned above with extensions.

when ::= is replaced with !!=, a shallow type is defined.
A shallow type is generaly a wrapper like 'type1 | type2 | ... | typen' but each type component
is not resolved and left as is.
For non shallow types, we will replace each type component that is a wrapper with the wrapped components
and so on recursively.

atom      ::=  identifier | literal | enclosure
<pre>
atom      ::=  identifier | literal | enclosure | builtin_object
builtin_object ::= 'None' | 'True' | 'False' | 'Ellipsis' | '...' |'NotImplemented'
any ::= any expression
</pre>


starred_list ::= starred_item ( ',' starred_item ) * [',']
<pre>
# starred_expression ::= expression | ( starred_item ',' )* [ starred_item ]
#starred_expression -> starred_item_list
#starred_expression ::= starred_item_list
starred_item_list ::= starred_item ? ( ',' starred_item ) * [',']
# starred_list ::=  starred_item ( "," starred_item )* [","]
starred_list ::= non_void_starred_item_list
non_void_starred_item_list ::= starred_item ( ',' starred_item ) * [',']
starred_item ::=  expression | star_expr
star_expr ::=  "*" or_expr
# expression_list -> non_void_expression_list
expression_list ::= non_void_expression_list
optional_expression_list ::= ( expression ',' )* [ expression ]
</pre>
<pre>
# literal ::= stringliteral | bytesliteral | integer | floatnumber | imagnumber
literal ::= shortliteral | longliteral | numberliteral
shortliteral ::= shortstringliteral | shortbytesliteral | shortformattedliteral
longliteral/literal ::= longstringliteral | longbytesliteral | longformattedliteral
shortstringliteral/literal ::= ''
shortbytesliteral/literal ::= b''
longstringliteral/literal ::= ''''''
longbytesliteral/literal ::= b''''''
bytesliteral ::= shortbytesliteral | longbytesliteral
stringliteral ::= shortbytesliteral | longbytesliteral
numberliteral ::= integer | floatnumber | imagnumber
integer/literal ::= 123
floatnumber/literal ::= 123.
imagnumber/literal ::= 123j
</pre>
Merge the two definitions
parenth_form ::=  "(" [starred_expression] ")"
expression_list    ::=  expression ( "," expression )* [","]
starred_list       ::=  starred_item ( "," starred_item )* [","]
starred_expression ::=  expression | ( starred_item "," )* [starred_item]
starred_item       ::=  expression | "*" or_expr
yield_atom       ::=  "(" yield_expression ")"
<pre>
parenth_form ::=  "(" starred_item_list | yield_expression ")"
</pre>

<pre>
comp_iter_list ::= (comp_iter) *
</pre>
list_display ::=  "[" [starred_list | comprehension] "]"
set_display ::=  "{" (starred_list | comprehension) "}"
<pre>
list_display ::=  "[" starred_item_list_comprehensive "]"
starred_item_list_comprehensive ::= starred_item | comprehension
starred_list -> non_void_starred_item_list
starred_list ::= non_void_starred_item_list
set_display ::=  "{" non_void_starred_item_list_comprehensive "}"
non_void_starred_item_list_comprehensive ::= starred_item | comprehension
</pre>
<pre>
key_datum_list_comprehensive ::= key_datum | dict_comprehension
key_datum ::= key_datum_s3d | or_expr_star_star
key_datum_s3d ::=  expression ":" expression
or_expr_star_star ::=  "**" or_expr
</pre>
The argument list is managed by the consolidator
'call' is not acceptable for a name because it is a reserved javascript word

call                 ::=  primary "(" [argument_list [","] | comprehension] ")"
argument_list        ::=  positional_arguments ["," starred_and_keywords]
                            ["," keywords_arguments]
                          | starred_and_keywords ["," keywords_arguments]
                          | keywords_arguments
positional_arguments ::=  ["*"] expression ("," ["*"] expression)*
starred_and_keywords ::=  ("*" expression | keyword_item)
                          ("," "*" expression | "," keyword_item)*
keywords_arguments   ::=  (keyword_item | "**" expression)
                          ("," keyword_item | "," "**" expression)*
keyword_item         ::=  identifier "=" expression


<pre>
call -> call_expr
call_expr/call ::=  primary "(" argument_list_comprehensive ")"
expression_star ::= "*" expression
expression_star_star ::= "**" expression
argument_any ::= expression | expression_star | expression_star_star | keyword_item
argument_list_comprehensive ::= argument_list | comprehension
argument_list ::=  argument_any *
positional_arguments ::=  REMOVE
starred_and_keywords ::=  REMOVE
keywords_arguments   ::=  REMOVE
starred_expression/starred ::= one of expression_star, expression_star_star, or_expr_star_star, star_expr
</pre>


<pre>
power ::= await_or_primary [ "**" u_expr ]
await_or_primary ::= primary
await_expr ::= REMOVE
</pre>
The await_expr is just a primary with an await attribute
<pre>
comparison ::=  or_expr | number_comparison | object_comparison
number_comparison/comparison ::= comparison comp_operator comparison
object_comparison/comparison ::= comparison comp_operator comparison
comp_operator ::= REMOVE
</pre>
<pre>
lambda ::= "lambda" [parameter_list]: (expression | expression_no_cond)
</pre>
These are auxiliary types used to check connections.
<pre>
algebra_choice ::= m_expr_s3d | a_expr_s3d
bitwise_choice ::= shift_expr_s3d | and_expr_s3d | xor_expr_s3d | or_expr_s3d
boolean_choice ::= and_test_s3d | or_test_s3d
unary_choice ::= u_expr_s3d | not_test_s3d
</pre>
</body>
</html>
