
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<body>
This HTML file is not expected to be rendered.
The purpose is just to give something similar to the official python documentation at
https://docs.python.org/3.6/reference/expressions.html
end next, in order to use the same parser.

What is important is enclosed between pre tags
Definitions follow the pseudo grammar use in the documentation mentioned above with extensions.

when ::= is replaced with !!=, a shallow type is defined.
A shallow type is generaly a wrapper like 'type1 | type2 | ... | typen' but each type component
is not resolved and left as is.
For non shallow types, we will replace each type component that is a wrapper with the wrapped components
and so on recursively.

This type is a shallow only type used with plugged_.
<pre>
not_a_variable !!=
</pre>

atom      ::=  identifier | literal | enclosure
<pre>
atom      ::=  identifier | literal | enclosure | builtin_object
builtin_object ::= 'None' | 'True' | 'False' | 'Ellipsis' | '...' |'NotImplemented'
any ::= any expression
</pre>


starred_list ::= starred_item ( ',' starred_item ) * [',']
<pre>
# starred_expression ::= expression | ( starred_item ',' )* [ starred_item ]
starred_expression -> starred_item_list
starred_expression ::= starred_item_list
starred_item_list ::= starred_item ? ( ',' starred_item ) * [',']
# starred_list ::=  starred_item ( "," starred_item )* [","]
starred_list ::= non_void_starred_item_list
non_void_starred_item_list ::= starred_item ( ',' starred_item ) * [',']
starred_item ::=  expression | star_expr
star_expr ::=  "*" or_expr
# expression_list -> non_void_expression_list
expression_list ::= non_void_expression_list
optional_expression_list ::= ( expression ',' )* [ expression ]
</pre>
<pre>
# literal ::= stringliteral | bytesliteral | integer | floatnumber | imagnumber
literal ::= stringliteral | numberliteral | imagnumber
numberliteral ::= bytesliteral | integer | floatnumber | numberliteral_concrete
</pre>
<pre>
comp_iter_list ::= (comp_iter) *
</pre>
list_display ::=  "[" [starred_list | comprehension] "]"
set_display ::=  "{" (starred_list | comprehension) "}"
<pre>
list_display ::=  "[" starred_item_list_comprehensive "]"
starred_item_list_comprehensive ::= starred_item | comprehension
starred_list -> non_void_starred_item_list
starred_list ::= non_void_starred_item_list
set_display ::=  "{" non_void_starred_item_list_comprehensive "}"
non_void_starred_item_list_comprehensive ::= starred_item | comprehension
</pre>
<pre>
key_datum_list_comprehensive ::= key_datum | dict_comprehension
key_datum ::= key_datum_concrete | or_expr_star_star
key_datum_concrete ::=  expression ":" expression
or_expr_star_star ::=  "**" or_expr
</pre>
<pre>
yield_expression ::=  yield_expression_list | yield_from_expression
yield_expression_list ::=  "yield" expression_list
yield_from_expression ::= "yield" "from" expression
</pre>
<pre>
attributeref ::= primary "." identifier
not_a_variable ||= attribute_identifier
</pre>
<pre>
slicing      ::=  primary display_slice_list
display_slice_list ::=  "[" slice_list "]"
</pre>
The argument list is managed by the consolidator
'call' is not acceptable for a name because it is a reserved javascript word
<pre>
call -> call_expr
call_expr ::=  primary "(" [argument_list [","] | comprehension] ")"
positional_arguments ::= REMOVE
expression_star ::= "*" expression
expression_star_star ::= "**" expression
any_argument ::= expression | expression_star | keyword_item | expression_star_star
any_argument_but_star_star ::= expression | expression_star | keyword_item
any_argument_but_expression ::=  expression_star | keyword_item | expression_star_star
any_argument_comprehensive ::= any_argument | comprehension
</pre>
<pre>
power ::= await_or_primary [ "**" u_expr ]
await_or_primary ::= await_expr | primary
</pre>
<pre>
comparison ::=  or_expr | number_comparison | object_comparison
number_comparison ::= comparison comp_operator comparison
object_comparison ::= comparison comp_operator comparison
</pre>
<pre>
lambda_expr ::= lambda_expression "dynamic with cond"
lambda_expr_nocond ::= lambda_expression "dynamic without cond"
lambda_expression ::= "lambda" [parameter_list]: (expression | expression_no_cond)
</pre>
These are auxiliary types used to check connections.
<pre>
algebra_concrete ::= m_expr_concrete | a_expr_concrete
bitwise_concrete ::= shift_expr_concrete | and_expr_concrete | xor_expr_concrete | or_expr_concrete
boolean_concrete ::= and_test_concrete | or_test_concrete
unary_concrete ::= u_expr_concrete | not_test_concrete
</pre>
</body>
</html>
