
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<body>
This HTML file is not expected to be rendered.
The purpose is just to give something similar to the official python documentation at
https://docs.python.org/3.6/reference/expressions.html
end next, in order to use the same parser.

What is important is enclosed between pre tags
Definitions follow the pseudo grammar use in the documentation mentioned above with extensions.

when ::= is replaced with !!=, a shallow type is defined.
A shallow type is generaly a wrapper like 'type1 | type2 | ... | typen' but each type component
is not resolved and left as is.
For non shallow types, we will replace each type component that is a wrapper with the wrapped components
and so on recursively.

This type is a shallow only type used with plugged_.
<pre>
not_a_variable !!=
</pre>

atom      ::=  identifier | literal | enclosure
<pre>
atom      ::=  identifier | literal | enclosure | builtin_object
builtin_object ::= 'None' | 'True' | 'False' | 'Ellipsis' | '...' |'NotImplemented'
any ::= any expression
</pre>


starred_list ::= starred_item ( ',' starred_item ) * [',']
<pre>
# starred_expression ::= expression | ( starred_item ',' )* [ starred_item ]
starred_expression -> starred_item_list
starred_expression ::= starred_item_list
starred_item_list ::= starred_item ? ( ',' starred_item ) * [',']
# starred_list ::=  starred_item ( "," starred_item )* [","]
starred_list ::= non_void_starred_item_list
non_void_starred_item_list ::= starred_item ( ',' starred_item ) * [',']
starred_item ::=  expression | star_expr
star_expr ::=  "*" or_expr
# expression_list -> non_void_expression_list
expression_list ::= non_void_expression_list
optional_expression_list ::= ( expression ',' )* [ expression ]
</pre>
<pre>
# literal ::= stringliteral | bytesliteral | integer | floatnumber | imagnumber
literal ::= stringliteral | numberliteral | imagnumber | docstring
numberliteral ::= bytesliteral | number | numberliteral_concrete
number ::= integer | floatnumber
</pre>
<pre>
comp_iter_list ::= (comp_iter) *
</pre>
list_display ::=  "[" [starred_list | comprehension] "]"
set_display ::=  "{" (starred_list | comprehension) "}"
<pre>
list_display ::=  "[" starred_item_list_comprehensive "]"
starred_item_list_comprehensive ::= starred_item | comprehension
starred_list -> non_void_starred_item_list
starred_list ::= non_void_starred_item_list
set_display ::=  "{" non_void_starred_item_list_comprehensive "}"
non_void_starred_item_list_comprehensive ::= starred_item | comprehension
</pre>
<pre>
key_datum_list_comprehensive ::= key_datum | dict_comprehension
key_datum ::= key_datum_concrete | or_expr_star_star
key_datum_concrete ::=  expression ":" expression
or_expr_star_star ::=  "**" or_expr
</pre>
<pre>
yield_expression ::=  yield_expression_list | yield_from_expression
yield_expression_list ::=  "yield" expression_list
yield_from_expression ::= "yield" "from" expression
</pre>
<pre>
attributeref ::= primary "." identifier
not_a_variable ||= attribute_identifier
</pre>
<pre>
slicing      ::=  primary display_slice_list
display_slice_list ::=  "[" slice_list "]"
</pre>
The argument list is managed by the consolidator
'call' is not acceptable for a name because it is a reserved javascript word

call                 ::=  primary "(" [argument_list [","] | comprehension] ")"
argument_list        ::=  positional_arguments ["," starred_and_keywords]
                            ["," keywords_arguments]
                          | starred_and_keywords ["," keywords_arguments]
                          | keywords_arguments
positional_arguments ::=  ["*"] expression ("," ["*"] expression)*
starred_and_keywords ::=  ("*" expression | keyword_item)
                          ("," "*" expression | "," keyword_item)*
keywords_arguments   ::=  (keyword_item | "**" expression)
                          ("," keyword_item | "," "**" expression)*
keyword_item         ::=  identifier "=" expression


<pre>
call -> call_expr
call_expr ::=  primary "(" argument_list_comprehensive ")"
expression_star ::= "*" expression
expression_star_star ::= "**" expression
argument_any ::= expression | expression_star | expression_star_star | keyword_item
argument_list_comprehensive ::= argument_list | comprehension
argument_list ::=  argument_any *
positional_arguments ::=  REMOVE
starred_and_keywords ::=  REMOVE
keywords_arguments   ::=  REMOVE
</pre>


<pre>
power ::= await_or_primary [ "**" u_expr ]
await_or_primary ::= await_expr | primary
</pre>
<pre>
comparison ::=  or_expr | number_comparison | object_comparison
number_comparison ::= comparison comp_operator comparison
object_comparison ::= comparison comp_operator comparison
comp_operator ::= REMOVE
</pre>
<pre>
lambda_expr ::= lambda_expression "dynamic with cond"
lambda_expr_nocond ::= lambda_expression "dynamic without cond"
lambda_expression ::= "lambda" [parameter_list]: (expression | expression_no_cond)
</pre>
These are auxiliary types used to check connections.
<pre>
algebra_choice ::= m_expr_concrete | a_expr_concrete
bitwise_choice ::= shift_expr_concrete | and_expr_concrete | xor_expr_concrete | or_expr_concrete
boolean_choice ::= and_test_concrete | or_test_concrete
unary_choice ::= u_expr_concrete | not_test_concrete
</pre>
</body>
</html>
