
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
</head>
<body>
if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
<pre>
if_part ::= "if" expression ":"
elif_part ::= "elif" expression ":"
else_part ::= "else" ":"
else_part > if_part | elif_part
elif_part > if_part | elif_part
</pre>
<pre>
while_part ::=  "while" expression ":"
else_part > while_part
</pre>
The last line means: an else_part comes just after a while_part.
For an < sign, it would read "just before".
Rules are cumulative, which means that A < B and A < C significates that A comes just before B or C.
<pre>
for_part ::=  "for" target_list "in" expression_list ":"
else_part > for_part
</pre>
<pre>
try_part ::=  "try" ":"
except_part ::= "except" expression ["as" identifier] ":"
void_except_part ::= "except" ":"
finally_part ::= "finally" ":"
try_part < except_part | void_except_part | finally_part
except_part < except_part | void_except_part | else_part | finally_part
void_except_part < finally_part
except_part > try_part | except_part
void_except_part > try_part | except_part
else_part > except_part | void_except_part
finally_part > try_part | except_part | void_except_part | else_part
</pre>
try_stmt  ::=  try1_stmt | try2_stmt
try1_stmt ::=  "try" ":" suite
               ("except" [expression ["as" identifier]] ":" suite)+
               ["else" ":" suite]
               ["finally" ":" suite]
try2_stmt ::=  "try" ":" suite
               "finally" ":" suite

with_stmt ::=  "with" with_item ("," with_item)* ":" suite
with_item ::=  expression ["as" target]

<pre>
with_part ::=  "with" with_item_list ":"
with_item_list ::= with_item ("," with_item)*
</pre>
with_item ::=  expression ["as" target]
If a parameter has a default value, all following parameters up until the “*” must also have a default value — this is a syntactic restriction that is not expressed by the grammar.


<pre>
funcdef_part ::= "def" funcname "(" [parameter_list] ")" ["->" expression] ":"
funcdef ::=
decorator_part ::=  "@" dotted_name ["(" [argument_list [","]] ")"]

decorator_part < decorator_part | funcdef_part
</pre>


parameter_list ::=  parameter_list_1 | parameter_list_2| parameter_list_starargs
parameter_list_1 ::= defparameter ("," defparameter)*
parameter_list_2 ::= defparameter ("," defparameter)* "," parameter_list_starargs

parameter_list_starargs ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                             | parameter_list_starargs_b
parameter_list_starargs_a ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
parameter_list_starargs_b ::=  "**" parameter [","]

parameter_list          ::=  defparameter ("," defparameter)* ["," [parameter_list_starargs]]
                             | parameter_list_starargs
parameter_list_starargs ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                             | "**" parameter [","]
parameter               ::=  identifier | parameter_annotated
parameter_annotated      ::=  identifier ":" expression
defparameter            ::=  parameter | parameter "=" expression
<pre>
parameter_list ::= REMOVE
parameter_star ::= "*" [parameter]
parameter_star_star ::= "**" parameter
parameter_any ::= parameter | defparameter | parameter_star | parameter_star_star
parameter_no_single_star ::= parameter | defparameter | parameter_star_star
parameter_no_star_star ::= parameter | defparameter | parameter_star
parameter_no_star ::= parameter | defparameter
</pre>

classdef    ::=  [decorators] "class" classname [inheritance] ":" suite
inheritance ::=  "(" [argument_list] ")"
classname   ::=  identifier

<pre>
classdef_part ::=  "class" classname [inheritance] ":"
classdef ::=
decorator_part < classdef_part
</pre>

<pre>
docstring_def_stmt ::= triple quoted long string at the top of the function or class
docstring_def_stmt > funcdef_part | classdef_part
</pre>


</body>
</html>